<!-- Temperory fix using inline styles, pending to contact UX team on this issue, list elements enlarge for every indent-->
<!DOCTYPE html>
<html>
  <head>
    <!--include subhead.txt -->
    <title>
    dockerSwarm
    </title>
    <!--include googleAnalyticsScript.txt -->
  </head>
  <body>
    <div class="wrapper">
    <!--include navbar.txt -->
    <div id="content">



    <h1>
      Deployment with Clusters
    </h1>
    <p>Deployment of an application in a container over a number
      of machines with replicas to scale the applications as well
      as recover from failures is the principle concept of cluster
      deployment.Such kind of deployment provision requires an
      automation infrastrucure to create, manage, maintain the clusters.
      Prominent cluster deployment and tools we will be looking at are,
    </p>
    <ol>
      <li><strong>Docker Swarm</strong></li>
      <li><strong>Kubernetes</strong></li>
    </ol>


    <h2>
    1. Docker Swarm
    </h2>
    <p>
    <img src="https://raw.githubusercontent.com/docker-library/docs/471fa6e4cb58062ccbf91afc111980f9c7004981/swarm/logo.png">
    </p>
    <p>A swarm is a group of machines running docker tied togther
      to form a cluster managed by a swarm manager. Once a cluster is
      created, all the machines tied together are referred to as
      nodes/workers.
      Only the swarm manager machine has authorization to execute commands
      or add more workers.
    </p>
    <ul class="nested">
      <li><strong>Swarm Manager</strong></li>
      <li><strong>Worker or Node</strong></li>
    </ul>



    <h2>Example of a Docker Swarm Deployment</h2>
    <p>
    Lets look at a demonstration of a cluster deployment using docker swarm
    </p>
    <h3>-- Aim:</h3>
    <p>To deploy the static webpage in a cluster with multiple
      instances using docker swarm</p>
    <ul class="nested">
      <li><p><b>Cluster/Nodes:</b> Group of virtual machines</p></li>
      <li><p><b>Application:</b> devOps wesite served as static web pages</p></li>
      <li><p><b>Tool Used:</b> Docker swarm</p></li>
    </ul>



    <h3>-- Components:</h3>
    <p><strong>* Swarm Manager -</strong> Assuming the local machine &lt;machine
      you are using&gt; or one of the cirtual machine to be the manager</p>
    <p><strong>* devOps website as a container -</strong></p>
    <ul class="nested">
      <li><strong>Dockerfile -</strong> Using standalone nginx container
          and serving the static webpages from source</li>
      <li><strong>DockerCompose -</strong> Using a combination of multiple containers
          of nginx &lt;to host the website&gt; + git-sync &lt;to sync with the
          repository&gt; + common container storage</li>
      <li><strong>Virutal machines -</strong>
          either remote cloud machines or local setup of vms using virutalBox</li>
      <li><strong>Setup Concern -</strong>
            Due to cloud machine availability, lets resort to a local setup for
            the example and peek into an instance of cloud deployment as well.</li>
    </ul>


    <h3>-- Detour: More on Docker and DockerCompose</h3>
    <p>while in this context, lets take a detour to briefly look at
      <em>dockerFile vs dockerCompose</em></p>
    <ul class="nested">
      <li><strong>dockerFile:</strong><br>
        When a self-contained container or monolithic container
        image is to be created which suffices the functionality
        within itself, a docker file is used<br>
        <img src="https://i.stack.imgur.com/jc2IW.jpg" title="dockerFile">
        <pre>
        <code>
          # DockerFile using Nginx base image and website source code copy from current directory
          # * Build image with the docker file and run &gtcommands below&lt
          # References:
          # * https://www.katacoda.com/courses/docker/create-nginx-static-web-server

          # Base Nginx docker image
          FROM nginx:alpine

          # Maintainer
          MAINTAINER Srinivas Piskala Ganesh Babu "spg349@nyu.edu"

          # Copy the DevOps repository contents present in the current directory to the default nginx web hosting directory
          COPY DevOps /usr/share/nginx/html

          # Usage:
          # * To update the website source files,
          # ** Clone the gcallah/DevOps repo at the same directory where dockerfile exists &gtgit clone&lt
          # *** build a new image with this dockerfile - "docker build -f DockerFile -t devopsweb ."
        </code>
      </pre>
      </li>
      <li><strong>dockerCompose:</strong><br>
      When multiple containers are required which together suffice a
      functionlity as a team, docker compose is used. We wont be using the below docker-compose
      for this example. The docker compose uses 2 containers to sync with the source code repository
      update the resources as well as host the website by sharing the same volume.
      The docker compose below is for demonstration purposes<br>
      <img src="https://raw.githubusercontent.com/docker/compose/master/logo.png" title="dockeCompose">
      <pre>
      <code>
        # A Docker compose to create the application with two containers
        # * 1. Nginx container
        # * 2. git-sync container
        # Reference from: https://hub.docker.com/r/openweb/git-sync/
        # Run with `docker-compose up -d` once the dockerCompose
        file is created
        version: "2"
          services:
            nginx:
              image: nginx:latest
              ports:
                - "8080:80"
              volumes:
                - website_sources:/usr/share/nginx/html:z
              depends_on:
                - git-sync
              restart: always
            git-sync:
              image: openweb/git-sync:0.0.1
              environment:
                GIT_SYNC_REPO: "https://github.com/gcallah/DevOps"
                GIT_SYNC_DEST: "/git"
                GIT_SYNC_BRANCH: "master"
                GIT_SYNC_REV: "FETCH_HEAD"
                GIT_SYNC_WAIT: "10"
              volumes:
                - website_sources:/git:z
              restart: always
          volumes:
            website_sources:
          driver: local
      </code>
    </pre>
    </li>
  </ul>


    <h3>-- Installation:</h3>
    <ul class="nested">
      <li><strong>Ensure docker is installed</strong>
      * Possess any virtual machine setup provision using virtualbox or
      vmware workstation or make cloud machines setup</li>
    </ul>



    <h5>-- Setup:</h5>
    <p><br><strong>TestBed Type 1 :</strong> Static SourceCode: Use the dockerfile
      and dockerCompose file below to establish the setup, <br>
      The Dockerfile created using the Nginx container and adding the website
      source code from current directory,
      <pre>
        <code>
          # DockerFile using Nginx base image and website source code copy from current directory
          # * Build image with the docker file and run &gtcommands below&lt
          # References:
          # * https://www.katacoda.com/courses/docker/create-nginx-static-web-server

          # Base Nginx docker image
          FROM nginx:alpine

          # Maintainer
          MAINTAINER Srinivas Piskala Ganesh Babu "spg349@nyu.edu"

          # Copy the DevOps repository contents present in the current directory to the default nginx web hosting directory
          COPY DevOps /usr/share/nginx/html

          # Usage:
          # * To update the website source files,
          # ** Clone the gcallah/DevOps repo at the same directory where dockerfile exists &gtgit clone&lt
          # *** build a new image with this dockerfile - "docker build -f DockerFile -t devopsweb ."
        </code>
      </pre>
    </p>

    <p><br><strong>TestBed Type 2:</strong> Dynamic SourceCode Fetch: Use
      the dockerfile and dockerCompose file below to establish the setup,<br>
      The Dockerfile is created using the UBUNTU base image with apt install
      nginx to host the webpage and apt install
      git to fetch the newest website resource from the repository.
      <pre>
        <code>
              # Docker file with Ubuntu Base image and performing apt install of,
              # * Nginx - To host the website
              # * Git   - To fetch the website resource from the git repository
              # References:
              # * https://docs.docker.com/get-started/part2/#apppy
              # * https://www.digitalocean.com/community/tutorials/docker-explained-using-dockerfiles-to-automate-building-of-images
              # * https://gist.github.com/ivanacostarubio/7044770

              # Latest ubuntu base image
              FROM ubuntu:latest

              # Maintainer
              MAINTAINER Srinivas Piskala Ganesh Babu "spg349@nyu.edu"

              # Apt update and install - nginx and git
              RUN apt-get update
              RUN apt-get install -y nginx
              RUN apt-get install -y git-core

              # Fetching the latest source code from the github repo of devOps
              RUN git clone https://github.com/gcallah/DevOps

              # Clean up of existing files in the default folder
              RUN rm /var/www/html/*

              # Uploading the webpages and resource to the default nginx config pointer folder
              RUN cp -a DevOps/. /var/www/html/

              # Expose ports
              EXPOSE 80

              # Nginx daemon run
              CMD ["nginx", "-g", "daemon off;"]

              # Usage:
              # * Use the docker build command to build an image out of this docker file or pull from rep
              # ** command: "docker build -f &gtname of the docker file&lt -t &gttag of the image&lt ."
              # *** repo to docker pull from: srinivas11789/devopswebsite
          </code>
        </pre>
      </p>

        <p><br><strong>Common File: </strong>Docker compose file common for both the testbeds, <br>
          Ensure to change the image name with the corresponding docker image created.
          <pre>
            <code>
              # Docker Compose file to build as a compose or stack or swarm
              # References:
              # * https://docs.docker.com/get-started/part3/#docker-composeyml
              # * https://docs.docker.com/get-started/part5/#persist-the-data

              # version
              version: "3"

              # services declaration
              services:
                # Name of the service and image details -
                # image   - Name of the image to pull from
                # port    - Port to expose or map
                # deploy  - configuration to deploy
                # replica - number of container to be replicated
                devops:
                  image: srinivas11789/devopswebsite:v1
                  ports:
                    - "80:80"
                  deploy:
                    mode: replicated
                    replicas: 3
                    labels: [APP=devops_website]
                    restart_policy:
                      condition: on-failure
            </code>
        </pre></p>



        <h5>Steps for Usage:</h5>
        <ul class="nested">
        <li> Use docker-machine command line to use the virtual box
          driver and create virtual machines for the cluster. For the
          demo, lets create three virtual machines. One being the master
          and the other two workers. Use the following command to perform
           the required operation
        <pre>
        <code>
          <span>
          docker-machine create --driver virtualbox myvm1
          docker-machine create --driver virtualbox myvm2
          docker-machine create --driver virtualbox myvm3
          </span>
        </code>
      </pre>
      <p>Command line output sample:</p>
      <pre>
      <code>
         <span>
          <b>MacBook-Pro:devOps deployment$ docker-machine create --driver virtualbox myvm1</b>
          Running pre-create checks...
          Creating machine...
          (myvm1) Copying /Users/darkknight/.docker/machine/cache/boot2docker.iso to /Users/darkknight/.docker/machine/machines/myvm1/boot2docker.iso...
          (myvm1) Creating VirtualBox VM...
          (myvm1) Creating SSH key...
          (myvm1) Starting the VM...
          (myvm1) Check network to re-create if needed...
          (myvm1) Waiting for an IP...
          Waiting for machine to be running, this may take a few minutes...
          Detecting operating system of created instance...
          Waiting for SSH to be available...
          Detecting the provisioner...
          Provisioning with boot2docker...
          Copying certs to the local machine directory...
          Copying certs to the remote machine...
          Setting Docker configuration on the remote daemon...
          Checking connection to Docker...
          Docker is up and running!
         </span>
      </code>
    </pre>
    </li>
    <li> List the virtual machines to look at the created vms.
      <pre>
        <code>
          <span>
          docker-machine ls
          </span>
        </code>
      </pre>
      <p>Command line output sample:</p>
      <pre>
      <code>
         <span>
          <b>MacBook-Pro:devOps deployment$ docker-machine ls</b>
          NAME      ACTIVE   DRIVER       STATE     URL                         SWARM   DOCKER        ERRORS
          myvm1     -        virtualbox   Running   tcp://192.168.99.100:2376           v18.03.1-ce
          myvm2     -        virtualbox   Running   tcp://192.168.99.101:2376           v18.03.1-ce
          myvm3     -        virtualbox   Running   tcp://192.168.99.102:2376           v18.03.1-ce
         </span>
      </code>
    </pre>
    </li>
        <li> The virtual machines can be connected using ssh to execute
          commands and make proper swarm setup. Consider the "vm1"
          machine as the master. Initiating the swarm from node1 "vm1"
          would make the current node as master
      <pre>
        <code>
          <span>
          docker-machine ssh myvm1 "docker swarm init --advertise-addr &ltmyvm1 ip&gt"
          </span>
        </code>
      </pre>
      <p>Command line output sample:</p>
      <pre>
      <code>
         <span>
          <b>MacBook-Pro:devOps deployment$ docker-machine ssh myvm1 "docker swarm init --advertise-addr 192.168.99.100"</b>
          Swarm initialized: current node (lhys3d8lpqc1onnikx5t9jaep) is now a manager.

          To add a worker to this swarm, run the following command:

          docker swarm join --token SWMTKN-1-0u40ts3aguqoa4jmt7rmrxh1gpkujs2fahhdmi55uz0eum3bxi-cwaxy2whk4pq2sxpg0g7prao0 192.168.99.100:2377

          To add a manager to this swarm, run 'docker swarm join-token manager' and follow the instructions.
         </span>
      </code>
    </pre>
    </li>
      <li> Next, the worker nodes have to configured such that
       they recognize the swarm configuration and know the master.
       Make sure to use the token and ip of the master node
       generated when swarm was initialized
      <pre>
        <code>
          <span>
          docker-machine ssh myvm2 "docker swarm join --token &lttoken&gt &ltip&gt:2377"
          </span>
        </code>
      </pre>
      <p>Command line output sample:</p>
      <pre>
      <code>
         <span>
          <b>MacBook-Pro:devOps deployment$ docker-machine ssh myvm2 "docker swarm join --token SWMTKN-1-0u40ts3aguqoa4jmt7rmrxh1gpkujs2fahhdmi55uz0eum3bxi-cwaxy2whk4pq2sxpg0g7prao0 192.168.99.100:2377"</b>
          This node joined a swarm as a worker.
         </span>
      </code>
    </pre>
    </li>
    </ul>


    <h3>References and Source:</h3>
    <ul class="nested">
      <li><a href="https://raw.githubusercontent.com/docker-library/">Docker Swarm Image</a></li>
      <li><a href="https://raw.githubusercontent.com/docker/compose/master/logo.png">Docker image</a></li>
      <li><a href="https://i.stack.imgur.com/jc2IW.jpg">Docker compose image</a></li>
      <li><a href="https://hub.docker.com/r/openweb/git-sync/">Docker compose concepts</a></li>
      <li><a href="https://docs.docker.com/get-started/part4/#configure-a-docker-machine-shell-to-the-swarm-manager">Docker swarm concepts</a></li>
    </ul>

    </div>
    </div>
    </body>
</html>
