<!DOCTYPE html>
<html>
    <head>
        <!--include subhead.txt -->
        <title>
            The Unix Programming Environment
        </title>
        <!--include googleAnalyticsScript.txt -->
    </head>

    <body>
        <div class="wrapper">
        <!--include navbar.txt -->
        <div id="content">
        <!--include menu.txt -->
        <h1>
            The Unix Programming Environment
        </h1>
        <p class="author">
            Brian W. Kernighan, Rob Pike
        </p>
        <p>
            Reviewers: Arun John Kuruvilla, Srinivas Piskala Ganesh Babu
        </p>
        <p>
            Helpful links: <a href="https://cs.uwec.edu/~buipj/teaching/cs.388.s14/"> Course&Book</a>
        </p>

        <h4>Chapter 1: UNIX for Beginners</h4>

        <p>
            The first chapter goes over introducing the basics of the unix
            system as well as giving an idea about the structure of the rest
            of the book. The book assumes that the reader has some familirity
            with using a terminal. The book also requires a copy of the
            <i>Programmer's Manual</i>. The objective of the chapter is to
            get the user started with his/her system as soon as possible.
        </p>
        <p>
            The chapter is split into three sections:
            <ul>
                <li>
                    <b>Basics</b> - logging, basic commands.
                </li>
                <li>
                    <b>Day-to-day use</b> - filesystems, printing, commonly
                    used commands.
                </li>
                <li>
                    <b>Command interpreter</b> - filename shorthands, pipes, etc.
                </li>
            </ul>
        </p>

        <h4>Chapter 2: The File System</h4>

        <p>
            Everything in UNIX is a file. This is the fundamental principle
            dating from the very beginining of UNIX. This approach was decided
            as an example of the "Keep It Simple" policy. This chapter dwells
            into the fundamentals of files and directories, permissions,
            inodes, and finally on the directory hierarchy.
        </p>
        <p>
            Files are a sequence of bytes. File types are not determined by
            the file system and the kernel treats every file as a sequence of
            bytes. The command <i>file</i> makes an educated guess at the
            type of file by using magic numbers.
        </p>
        <p>
            Every file has has permissions, restricting who can read, write or
            execute the file. However, every system has a <i>Super user</i>,
            who can read, write, or execute any file on the system. A user can
            use a program called <i>crypt</i> to encrypt his/her files, which
            can prevent the superuser cannot modify the file.
        </p>
        <p>
            All the admnistrative components of a file, such as the name,
            permissions, and modification times are stored separately as
            inodes. Inodes themselves are files, and keep the contents of the
            files separate from the administrative metadata. This increases
            access times, as many a times the contents of the file are not
            required, but only the administrative metadata.
        </p>
        <p>
            The unix system uses a directory hierachy starting from "/". They
            are as follows:
        </p>
        <ul>
            <li>bin</li>
            <li>boot</li>
            <li>dev</li>
            <li>etc</li>
            <li>lib</li>
            <li>tmp</li>
            <li>unix</li>
            <li>usr</li>
        </ul>
        <p>
            Each of these directories serve a specific purpose. <b><i>/bin
            </i></b> is the direcotry which contains basic binaries such as
            <i>who</i> and <i>ed</i>. <b><i>/dev</i></b> contains device
            files. <b><i>/etc</i></b> contains device administration files,
            such as password and configuration files. <b><i>/lib</i></b>
            contains parts of the C compiler. <b><i>/tmp</i></b> contains
            temprory files used by different programs. <b><i>/usr</i></b>
            is the user file system.
        </p>
        <p>
            Devices are mounted as regular files inside the <b><i>/dev</i>
            </b> folder. Instead of coming up with different and special
            routines for each of the devices, Unix considers all devices
            as files. Inside the kernel, refernces to that file are converted
            into hadware commands according to the device. For example, when a
            file <b><i>/dev/mnt0</i></b> is read by the operating system, the
            kernel converts the read command to the device specific read
            command and returns the required bytes. This way, every device
            is treated like a stream of bytes. <b><i>/dev/null</i></b> is a
            special file to which output from any program can be redirected,
            causing the output to be thrown away.
        </p>

        <h4>Chapter 3: Using the Shell</h4>

        <p>
            This chapter goes ahead to explain one of the most frequently
            used programs and one of the most important program for unix
            users. The shell helps in automating and carrying out a lot of
            tasks without resorting to programming languages such as C. The
            shell takes commands and runs them line by line. Other than
            characters, the shell recongnises meta characters, such as <b>*
            </b>. Shell commands are not limited to the ones that already
            exist. The command "<i>new</i>" command can be used to concatenate
            multiple commands to create new commands for specific purposes.
        </p>
        <p>
            Just like any other programming language, the shell too has
            variables. Argumental variables, such as $1, are used to pass data
            to programs. The digit indicates the position in the argument
            list, with $0 being the name of the command. Shell variables can
            be created, accessed, and modified. Some shell variables, such as
            <b>PATH</b> and <b>HOME</b> hold special meaning to commands, and
            may cause other programs to crash if they do not contain proper
            values. Other that those variables, new variables can be created
            and used as the user desires.
        </p>

        <h4>Chapter 4: Filters</h4>
        <p>
           This chapter dives into various filters in unix to perform,
           <b>input (stdin) ===&gt processing (pattern) ===&gt output (stdout)</b>
           operations based on categories of data tranformation filters vs
           programmable filters. This chapter dives into various filters in unix to perform,
           <b>input (stdin) ===&gt processing (pattern) ===&gt output (stdout)</b>
           operations based on categories of data tranformation filters vs
           programmable filters. The chapter goes through different filters specifically
           grep and techniques for optimal usage by combining different filters for different
           tasks with some examples.
        </p>

        <h4>Chapter 5: Shell Programming</h4>
        <p>
        This chapter starts with a definition of shell being more of a programming language
        than a interactive command line interpreter where each statement runs as a command.
        The author also argues the content with a lot of shell programming techniques and examples
        should not be considered a manual page rather a reference or guide with examples. A good
        example of calendar - cal command was depicted with the steps showing how to customize a
        command based on your needs.
        </p>

        <h4>Chapter 6: Programming with Standard I/O</h4>
        <p>

        </p>
        <h4>Chapter 7: UNIX System Calls</h4>
        <h4>Chapter 8: Program Development</h4>
        <h4>Chapter 9: Document Preparation</h4>
    </div>
    </div>
    </body>
</html>
