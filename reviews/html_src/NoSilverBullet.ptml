<!DOCTYPE html>
<html>
    <head>
<!--include subhead.txt -->
        <title>
            No Silver Bullet
        </title>
        <!--include googleAnalyticsScript.txt -->
    </head>

    <body>
        <div class="wrapper">
<!--include navbar.txt -->
        <div id="content">
            <h1>
                No Silver Bullet
            </h1>

            <p class="author">
                Frederick P. Brooks, Jr
            </p>

            <p>
                Reviewer: Tingjun Zhang
            </p>

            <h4>
                What is this article about?
            </h4>
            <p>
                When it comes to software developing, people are always
                getting into some troubles, such as missed schedules,
                blown budgets, and flawed products,
                which make developing work very painful.
                People are desperate to find a silver bullet
                (an ultimate solution) for those problems.
                However, when we look back at the past decade,
                we see no silver bullet.
            </p>
            <p>
                This article is trying to tell us why
                there is still no silver bullet,
                past breakthroughs against those issues
                and future hope for the silver
                (potential ultimate solutions).
            </p>
            <h4>
                Essential Difficulties
            </h4>
            <p>
                The author clarifies that the relatively slow
                pace of software progress is normal.
                The rapid development of computer hardware is extremly
                unique throughout the entire human history.
                Comparison between progresses of software and hardware is
                neither fair nor reasonable.
            </p>
            <p>
                The most difficult parts, such as specification, design
                and testing of conceptual construct, are fuzzy, which
                makes software hard inherently.
            </p>
            <p>
                The author concludes 4 main properties of the
                essential difficulties : complexity, conformity,
                changeability, and invisibility.
            </p>
            <p>
                <ul>
                    <li>
                        <b>Complexity</b> - The Software itself
                        is more complex than other
                        human construct. And since software systems have
                        more states than computers do, their complexity
                        would increase much more than linearly.
                        Unlike mathematics and the physical sciences, 
                        the complexities
                        are the essential properties of software 
                        development, which is
                        one of the reason why it is almost impossible 
                        to abstract certain
                        essence to simplicify problems we 
                        faced during software developing.
                        Both technical problems and management
                         problems count when we try
                        to overview and control all loose ends.
                    </li>
                </ul>
                <ul>
                    <li>
                        <b>Conformity</b> - 
                        Conformation to other complex interfaces
                        is a must for the software. 
                        And many complexities come from
                        those conformations, which can not be avoided.
                    </li>
                </ul>
                <ul>
                    <li>
                        <b>Changeability</b> - 
                        Software is infinitely malleable. Unlike
                        buildings, cars and computers, 
                        software changes are
                        not that expansive and hard. 
                        Software is highly related to
                        applications, users, laws, 
                        and machine vehicles. Their changes will
                        force software to change.
                    </li>
                </ul>
                <ul>
                    <li>
                        <b>Invisibility</b> - 
                        For the current period, there is still not
                        a ready geometric representation for software,
                        which made it hard for communication when 
                        developers are trying to discuss about the design.                        
                    </li>
                </ul>
            </p>

            <h4>
                Past Breakthroughs Solved Accidental Difficulties
            </h4>
            <p>
                The author gives three important breakthroughs in software
                development in the past.
            </p>
            <p>
                <ul>
                    <li>
                        <b>High-level languages</b> - 
                        A high-level language that can potentially ease
                        the pain for accidental complexity. However,
                        sometimes it would create a 
                        tool-mastery burden to developers.
                    </li>
                </ul>
                <ul>
                    <li>
                        <b>Time-sharing</b> - 
                        It shortens system response time, but once
                        the response time goes less 
                        than 100 milliseconds, to human race,
                        no further benefits are to be expected.
                    </li>
                </ul>
                <ul>
                    <li>
                        <b>Unified programming environments</b> - 
                        Because of them, each
                        new tool could be applied to 
                        any programs that used standard formats,
                        which attack the accidental 
                        difficulties that result from using
                        individual programs together.
                    </li>
                </ul>
            </p>

            <h4>
                Hopes for the Silver
            </h4>            
            <p>
                <ul>
                    <li>
                        <b>Ada and other high-level language advances</b> - 
                        As a general-purpose high-level language, it provides
                        a philosophy of modularization, abstract data types and
                        hierarchical structuring. Entry level programmers could
                        benefit from the transition up from accidental complexities
                        into such more abstract structured solutions.
                    </li>
                </ul>
                <ul>
                    <li>
                        <b>Object-oriented programming</b> - 
                        It can help remove all the accidental 
                        difficulties from the expression of the design, but the
                        author doesn't think it won't help for problems caused
                        by the complexities of the design itself.
                    </li>
                </ul>
                <ul>
                    <li>
                        <b>Artificial intelligence</b> - 
                        The main idea is that the author doesn't 
                        think AI would 
                        provide any revolutionary breakthroughs.
                        The reason he gives is that 
                        current AI techniques used in speech/image
                        recognition don't have appreciable 
                        difference compared
                        with other programming practice.
                        Current AI techniques 
                        are unable to make abstraction 
                        for certain problems, in 
                        other words, the AI today still can't "think".
                        
                    </li>
                </ul>
                <ul>
                    <li>
                        <b>Expert systems</b> - 
                        The author claimed that the expert systems
                        are the most important part of the artificial
                        intelligence art. The author believes that
                        this technology provides the separation of
                        the application complexity from the program itself.
                        In software engineering tasks, it may give suggestions
                        on testing strategies, which benefits inexperienced
                        programmer a lot.
                    </li>
                </ul>
                <ul>
                    <li>
                        <b>Other approaches</b> -
                        The author also introduced some other approaches
                        such as,
                        automatic programming, graphical programming, program
                        verification, environments & tools and workstations.
                    </li>
                </ul>
            </p>
            <h4>
                Promising Attacks on the Conceptual Essence
            </h4> 
                <p>
                    The author gives some technological attacks that
                    are promising to solve software problems.
                </p>
                <p>
                    Three most essential aspects are: "Buy vesus build",
                    "Requirements refinement and rapid prototyping" and
                    "Great designers".
                </p>
            </div>
        </div>
    </body>
</html>
