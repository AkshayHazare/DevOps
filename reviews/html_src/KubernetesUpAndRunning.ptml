<!DOCTYPE html>
<html>
    <head>
<!--include subhead.txt -->
        <title>
            Kubernetes Up and Running
        </title>
        <!--include googleAnalyticsScript.txt -->
    </head>
    <body>
        <div class="wrapper">
<!--include navbar.txt -->
            <div id="content">
                <h1>
                    Kubernetes Up and Running
                </h1>
                <p class="author">
                    Authors: Kelsey Hightower, Brendan Burns, and Joe Beda
                    <br>
                    Reviewers: Ravish Bhatia, Sneha Ghosh
                </p>
                <p>
                </p>
                <details>
                <summary class="sum2">
                    Chapter 1: Introduction
                </summary>
                <p>
                This chapter provides a quick introduction to Kubernetes with 
                its several benefits. Kubernetes is an open source tool for 
                deploying containerized applications and can be used to deploy 
                scalable, reliable distributed systems. It provides benefits 
                like velocity, scaling, abstraction of infrastructure and 
                efficiency. The authors also describe how these benefits are 
                easily achieved by using Kubernetes for deployment.
                </p>
                </details>
                <details>
                <summary class="sum2">
                    Chapter 2: Creating and Running Containers
                </summary>
                <p>
                This chapter starts by discussing the problems that occur in
                distributed system such as applications having dependency on
                shared library or any dependency on asset files which causes
                failures or complexities when deployed in production. Then the
                solution for these problems are discussed which involve using 
                container immutable images for deploying the application. 
                Docker is the most popular container image that can package an 
                application and is supported by Kubernetes. The authors then 
                discuss how to package an application into Docker image, 
                security related considerations to keep in mind while building
                images and how to optimize image sizes. The authors recommend
                storing images in remote repository and describe its benefits.
                Then they discuss how to start running the application using
                docker image, how to limit resource utilization while running
                and in the end how to clean up docker images.
                </p>
                </details>
                <details>
                <summary class="sum2">
                    Chapter 3: Deploying a Kubernetes Cluster
                </summary>
                <p>
                In this chapter steps for installing Kubernetes cluster are
                discussed. The steps for installing Kubernetes on 3 major
                cloud providers Google Cloud Platform, Amazon Web Services and
                Microsoft Azure is described. Then steps for deploying
                Kubernetes single node cluster on local machine using minikube
                is discussed. The commands using kubectl which is the
                Kubernetes client for exploring the cluster and verifying its
                health are described. At last, the Kubernetes cluster
                components like Kubernetes Proxy, Kubernetes DNS and
                Kubernetes UI and their role within the cluster is discussed. 
                </p>
                </details>
                <details>
                <summary class="sum2">
                    Chapter 4: Common kubectl Commands
                </summary>
                <p>
                In this chapter, the authors dive into one of the command 
                line utilities of Kubernetes called, 'kubectl' which is 
                basically responsible for creating objects and interacting
                with kubernetes APIs. Then they briefly talk about namespaces
                for the organization of objects in a cluster, and to 
                permanently store the naming schema in the config file, 
                'context' is used. One of the important utility of kubectl 
                apart from the creation of API objects is viewing them. 
                Kubectl also enables users to create update and delete the 
                kubernetes objects. Also, it enables the commands for 
                debugging of the container and can execute the logs. 
                The authors have discussed the annotations and labels of 
                the objects as well, which has been discussed in details 
                in Chapter 6. 
                </p>
                </details>
                <details>
                <summary class="sum2">
                    Chapter 5: Pods
                </summary>
                <p>
                The authors explain the core concept of Kubernetes called 
                'Pods', which are considered as the smallest deployable 
                unit in a kubernetes environment. It is a collection of 
                multiple containers and volumes in a same execution 
                environment. They explain the behavior of how application 
                containers in the same pod will be different from containers 
                in different pods to clarify the network understanding of the 
                pods. Authors also exemplified the issues when two different 
                applications are scaled with the same strategy within a pod, 
                and how it could defeat the purpose of containers. To define 
                a pod, users have to define the kubernetes API object details 
                in a pod manifestation, which aligns with the declarative 
                configuration principle. The authors further define 
                technicalities and provide details in creating, running and 
                listing of pods. To summarize the concept, authors also 
                mention the multiple ways of using volumes with Pods. 
                </p>
                </details>
                <details>
                <summary class="sum2">
                    Chapter 6: Labels and Annotations
                </summary>
                <p>
                After explaining the core concept of Pods, the authors 
                immediately discuss the foundational concepts like Labels and 
                Annotations. Authors feel that Labels and Annotations are 
                often wrongly considered as the same concept and thus make a 
                great effort in explaining the difference and why it is 
                actually required to differentiate between the two. Authors 
                state that 'labels' are basically key-value pair and are 
                useful in attaching identifiable information to kubernetes 
                objects like Pods. Whereas, 'annotations' are storage 
                technique designed to hold unidentifiable information which 
                can be used by tools and libraries. The authors further 
                explain the application of labels and their modification 
                with help of commands and examples. Further, the authors 
                provide insight on annotation with detailed applicability.
                </p>
                </details>
                <details>
                <summary class="sum2">
                    Chapter 7: Service Discovery
                </summary>
                <p>
                The authors start by defining what Service discovery is and
                the characteristics of a good service discovery system. Since
                Kubernetes is a dynamic system where applications are placed
                dynamically, service discovery is crucial to fully utilize the
                power of Kubernetes. The service object allows to expose
                services within and outside the cluster. Kubernetes provides a
                DNS service which provides DNS names for cluster IPs, exposed
                to Pods running in the cluster. The authors also describe how
                to add readiness check within deployment to track which pods
                are ready. Some advanced features like using Endpoints to
                communicate directly with the service are also discussed.
                </p>
                </details>
                <details>
                <summary class="sum2">
                    Chapter 8: ReplicaSets
                </summary>
                <p>
                Building on the information provided in the chapter 5: Pods, 
                the authors in this sections explains the concept of 
                ReplicaSets to  ensure redundancy for making the system failure
                tolerant, scaling and sharding of the Pods. In a cluster, the 
                ReplicaSets are important to support the declarative 
                configuration of desired state and current state on the basis 
                of reconciliation loops. The authors also discuss the loosely 
                coupled relationship between Pods and ReplicaSets. The later 
                part of the chapter involves a technical overview of the 
                ReplicaSets with various specifications, templates and labels. 
                The Authors have also provided with multiple commands and 
                declarative configs for creating, inspecting,scaling and 
                deleting a ReplicaSet. One of the interesting take away from 
                the chapter is the auto-scaling based on the CPU usage which 
                is commonly used for Pods scaling.
                </p>
                </details>
                <details>
                <summary class="sum2">
                    Chapter 9: DaemonSets
                </summary>
                <p>
                In this chapter, the authors present an in-depth discussion 
                on DaemonSet, which is basically responsible for deploying 
                the system daemons like log collectors and monitoring agent.
                Authors define the similarity and difference between the 
                concept and use of ReplicaSet and DaemonSet. The relationship 
                between these two components of Kubernetes gives great idea 
                behind the 'decoupled architecture' of Kubernetes. The authors 
                further explain the practical examples of creating, updating 
                and deleting DaemonSet in a K8 environment. DaemonSets are 
                critical in an autoscaled Kubernetes cluster where nodes may 
                constantly be coming and going without user intervention.
                </p>
                </details>
                <details>
                <summary class="sum2">
                    Chapter 10: Jobs
                </summary>
                <p>
                Until now, the authors have only discussed the major components
                for running and maintaining the long-term processes, however, 
                in this section, they have presented a discussion on 
                short-lived or short-term process executing objects called 
                'jobs'. The basic idea behind jobs is to create pods until 
                successful termination is received, that is, if a pod fails 
                before a successful termination, the job object will create a 
                new pod based on the declarative configuration template until 
                successful termination is achieved. The authors have also 
                explained in detail the two attributes of job patterns like 
                'completions' and 'parallelism'. The authors concluded the 
                chapter by defining a job as low-level primitive which can be 
                used for simple workloads but can be used for high-level 
                orchestration systems.
                </p>
                </details>
                <details>
                <summary class="sum2">
                    Chapter 11: ConfigMaps and Secrets
                </summary>
                <p>
                In this chapter authors discuss about config maps and secrets
                and how they can make the container images reusable across
                environments or applications. Since config map is associated
                with the Pod before running they can help reusing image and
                pod across many applications by using different config map. 
                Then the authors describe how to create and use a config map
                with code sample. For handling the sensitive information,
                Kubernetes API for secrets is used, which also allows
                container images to be reused across environments. Next the
                authors go in detail describing how to create and consume
                secrets. How to access images stored in private registries
                using secret API for storing credentials. In the end, the
                naming conventions for config maps and secrets and some more
                commands to manage them are described.
                </p>
                </details>
                <details>
                <summary class="sum2">
                    SOURCE AND BOOK AVAILABILITY
                </summary>
                <p>
                E-BOOK: https://www.safaribooksonline.com/library/view/
                kubernetes-up-and/9781491935668/ <br><br>
                PAPERBACK: https://www.amazon.com/Kubernetes-Running-Dive-
                Future-Infrastructure/dp/1491935677
                </p>
                </details>


            </div>
        </div>
    </body>
</html>
